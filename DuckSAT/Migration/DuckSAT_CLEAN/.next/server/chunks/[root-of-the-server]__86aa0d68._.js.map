{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lionv/DuckSAT/Migration/DuckSAT_CLEAN/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined\r\n}\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\r\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/lionv/DuckSAT/Migration/DuckSAT_CLEAN/src/app/api/questions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { Prisma } from '@prisma/client';\r\n\r\n/**\r\n * Helper function to detect if an error is a retryable database connection error\r\n */\r\nfunction isRetryableError(error: unknown): boolean {\r\n  if (!error) return false;\r\n  \r\n  // Check for PrismaClientInitializationError\r\n  if (error && typeof error === 'object' && 'name' in error) {\r\n    const errorName = (error as { name: string }).name;\r\n    if (errorName === 'PrismaClientInitializationError') {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Check for common connection error codes\r\n  if (error && typeof error === 'object' && 'code' in error) {\r\n    const errorCode = (error as { code: string }).code;\r\n    if (['ECONNREFUSED', 'ENOTFOUND', 'ETIMEDOUT', 'ECONNRESET'].includes(errorCode)) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Check error message for connection-related issues\r\n  if (error instanceof Error) {\r\n    const message = error.message.toLowerCase();\r\n    if (\r\n      message.includes('connection') ||\r\n      message.includes('timeout') ||\r\n      message.includes('reach database') ||\r\n      message.includes('econnrefused') ||\r\n      message.includes('enotfound')\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  return false;\r\n}\r\n\r\n/**\r\n * Retry helper with exponential backoff for database operations\r\n * @param operation - The async operation to retry\r\n * @param maxAttempts - Maximum number of attempts (default: 3)\r\n * @param delays - Array of delay times in milliseconds for each retry (default: [200, 500, 1000])\r\n */\r\nasync function retryWithBackoff<T>(\r\n  operation: () => Promise<T>,\r\n  maxAttempts = 3,\r\n  delays = [200, 500, 1000]\r\n): Promise<T> {\r\n  let lastError: unknown;\r\n  \r\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n    try {\r\n      return await operation();\r\n    } catch (error) {\r\n      lastError = error;\r\n      \r\n      // Only retry if it's a retryable error and we have attempts left\r\n      if (!isRetryableError(error) || attempt === maxAttempts) {\r\n        throw error;\r\n      }\r\n      \r\n      // Wait before retrying (exponential backoff)\r\n      const delay = delays[attempt - 1] || delays[delays.length - 1];\r\n      console.log(`[/api/questions] Retry attempt ${attempt}/${maxAttempts} after ${delay}ms due to connection error`);\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n  }\r\n  \r\n  throw lastError;\r\n}\r\n\r\n/**\r\n * GET /api/questions\r\n * \r\n * Fetches questions with filtering, pagination, and related data.\r\n * \r\n * Note: This implementation uses Prisma's ORM methods (findMany, count) which are\r\n * safe and preferred over raw SQL queries. If raw SQL queries are needed in the future,\r\n * refer to @/lib/prismaQueryUtils for safe parameterized query patterns.\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const category = searchParams.get('category');\r\n    const subtopic = searchParams.get('subtopic');\r\n    const source = searchParams.get('source');\r\n    const search = searchParams.get('search');\r\n    const sortOrderParam = searchParams.get('sortOrder');\r\n    const sortOrder: 'asc' | 'desc' = sortOrderParam === 'asc' ? 'asc' : 'desc';\r\n    \r\n    // Validate and sanitize pagination parameters\r\n    const limitParam = searchParams.get('limit');\r\n    const offsetParam = searchParams.get('offset');\r\n    const parsedLimit = parseInt(limitParam || '50', 10);\r\n    const parsedOffset = parseInt(offsetParam || '0', 10);\r\n    \r\n    if (isNaN(parsedLimit) || isNaN(parsedOffset)) {\r\n      console.error('[/api/questions] Invalid pagination parameters', { limit: limitParam, offset: offsetParam });\r\n      return NextResponse.json({\r\n        error: 'Invalid pagination parameters',\r\n        details: 'Limit and offset must be valid numbers'\r\n      }, { status: 400 });\r\n    }\r\n    \r\n    const limit = Math.min(Math.max(parsedLimit, 1), 100);\r\n    const offset = Math.max(parsedOffset, 0);\r\n\r\n    // Build where clause\r\n    const where: Prisma.QuestionWhereInput = {\r\n      isActive: true\r\n    };\r\n\r\n    if (category) {\r\n      where.category = category;\r\n    }\r\n\r\n    if (subtopic) {\r\n      where.subtopic = subtopic;\r\n    }\r\n\r\n    if (source) {\r\n      where.source = source;\r\n    }\r\n\r\n    if (search) {\r\n      const s = search;\r\n      where.OR = [\r\n        { question: { contains: s, mode: 'insensitive' } },\r\n        { category: { contains: s, mode: 'insensitive' } },\r\n        { \r\n          AND: [\r\n            { passage: { not: null } },\r\n            { passage: { contains: s, mode: 'insensitive' } }\r\n          ]\r\n        },\r\n        { \r\n          AND: [\r\n            { subtopic: { not: null } },\r\n            { subtopic: { contains: s, mode: 'insensitive' } }\r\n          ]\r\n        }\r\n      ];\r\n    }\r\n \r\n    console.log('[/api/questions] Fetching questions with filters:', { \r\n      category, \r\n      subtopic, \r\n      source, \r\n      search: search ? `${search.substring(0, 20)}...` : null,\r\n      sortOrder,\r\n      limit,\r\n      offset\r\n    });\r\n    \r\n    // Fetch questions with related data with retry logic\r\n    let rawQuestions;\r\n    let questions;\r\n    try {\r\n      rawQuestions = await retryWithBackoff(async () => {\r\n        return await prisma.question.findMany({\r\n          where,\r\n          select: {\r\n            id: true,\r\n            subtopicId: true,\r\n            moduleType: true,\r\n            difficulty: true,\r\n            category: true,\r\n            subtopic: true,\r\n            question: true,\r\n            passage: true,\r\n            options: true,\r\n            correctAnswer: true,\r\n            explanation: true,\r\n            wrongAnswerExplanations: true,\r\n            imageUrl: true,\r\n            imageAlt: true,\r\n            imageData: true,\r\n            imageMimeType: true,\r\n            chartData: true,\r\n            timeEstimate: true,\r\n            source: true,\r\n            tags: true,\r\n            isActive: true,\r\n            reviewStatus: true,\r\n            reviewComments: true,\r\n            reviewedBy: true,\r\n            reviewedAt: true,\r\n            createdAt: true,\r\n            updatedAt: true,\r\n            subtopicRef: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                description: true,\r\n                topic: {\r\n                  select: {\r\n                    id: true,\r\n                    name: true,\r\n                    moduleType: true\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          },\r\n          orderBy: {\r\n            createdAt: sortOrder\r\n          },\r\n          take: limit,\r\n          skip: offset\r\n        });\r\n      });\r\n      \r\n      // Convert binary imageData to base64 strings\r\n      questions = rawQuestions.map(q => ({\r\n        ...q,\r\n        imageData: q.imageData ? Buffer.from(q.imageData).toString('base64') : null\r\n      }));\r\n      \r\n      console.log(`[/api/questions] Found ${questions.length} questions`);\r\n    } catch (dbError) {\r\n      console.error('[/api/questions] Database error fetching questions:', dbError);\r\n      \r\n      // Check if this is a retryable connection error that exhausted retries\r\n      if (isRetryableError(dbError)) {\r\n        return NextResponse.json({\r\n          error: 'database_unavailable',\r\n          message: 'Database is temporarily unavailable. Please try again later.',\r\n          details: dbError instanceof Error ? dbError.message : 'Unknown database error',\r\n          timestamp: new Date().toISOString()\r\n        }, { status: 503 });\r\n      }\r\n      \r\n      // Non-retryable error\r\n      return NextResponse.json({\r\n        error: 'Database error while fetching questions',\r\n        details: dbError instanceof Error ? dbError.message : 'Unknown database error',\r\n        timestamp: new Date().toISOString()\r\n      }, { status: 500 });\r\n    }\r\n\r\n    // Get total count for pagination with retry logic\r\n    let totalCount;\r\n    try {\r\n      totalCount = await retryWithBackoff(async () => {\r\n        return await prisma.question.count({ where });\r\n      });\r\n      console.log(`[/api/questions] Total count: ${totalCount}`);\r\n    } catch (countError) {\r\n      console.error('[/api/questions] Error counting questions:', countError);\r\n      // Continue with questions but set count to unknown\r\n      totalCount = questions.length;\r\n    }\r\n\r\n    // Get unique categories and subtopics for filtering with retry logic\r\n    let categories: Array<{ category: string }> = [];\r\n    let subtopics: Array<{ subtopic: string | null }> = [];\r\n    let sources: Array<{ source: string | null }> = [];\r\n    try {\r\n      [categories, subtopics, sources] = await retryWithBackoff(async () => {\r\n        return await Promise.all([\r\n          prisma.question.findMany({\r\n            where: { isActive: true },\r\n            select: { category: true },\r\n            distinct: ['category']\r\n          }),\r\n          prisma.question.findMany({\r\n            where: { isActive: true, subtopic: { not: null } },\r\n            select: { subtopic: true },\r\n            distinct: ['subtopic']\r\n          }),\r\n          prisma.question.findMany({\r\n            where: { isActive: true, source: { not: null } },\r\n            select: { source: true },\r\n            distinct: ['source']\r\n          })\r\n        ]);\r\n      });\r\n      console.log(`[/api/questions] Filters loaded: ${categories.length} categories, ${subtopics.length} subtopics, ${sources.length} sources`);\r\n    } catch (filterError) {\r\n      console.error('[/api/questions] Error fetching filter options:', filterError);\r\n      // Return empty arrays as fallback\r\n      categories = [];\r\n      subtopics = [];\r\n      sources = [];\r\n    }\r\n\r\n    // Normalize result to ensure consistent types and clearer text\r\n    const decodeHTMLEntities = (text: string): string => {\r\n      if (typeof text !== 'string') return '';\r\n      try {\r\n        return text\r\n          // Decode common HTML entities\r\n          .replace(/&nbsp;/g, ' ')\r\n          .replace(/&lt;/g, '<')\r\n          .replace(/&gt;/g, '>')\r\n          .replace(/&quot;/g, '\"')\r\n          .replace(/&apos;/g, \"'\")\r\n          // Numeric entities (decimal and hex)\r\n          .replace(/&#(\\d+);/g, (_m, code) => String.fromCharCode(Number(code)))\r\n          .replace(/&#x([0-9a-fA-F]+);/g, (_m, hex) => String.fromCharCode(parseInt(hex, 16)))\r\n          // Decode ampersand last to avoid double-decoding\r\n          .replace(/&amp;/g, '&');\r\n      } catch (err) {\r\n        console.error('Error in decodeHTMLEntities:', err, 'Input:', text);\r\n        return text;\r\n      }\r\n    };\r\n\r\n    const cleanText = (text: unknown): string => {\r\n      if (typeof text !== 'string') return '';\r\n      try {\r\n        const stripped = text.replace(/^\\s*[\"']|[\"']\\s*$/g, '');\r\n        const decoded = decodeHTMLEntities(stripped);\r\n        return decoded\r\n          .split(/\\r?\\n/)\r\n          .map((line) => line.replace(/[ \\t]+/g, ' ').trim())\r\n          .join('\\n')\r\n          .trim();\r\n      } catch (err) {\r\n        console.error('Error in cleanText:', err, 'Input:', text);\r\n        return String(text);\r\n      }\r\n    };\r\n    \r\n    const cleanOptionalText = (text: unknown): string | undefined => {\r\n      if (text == null) return undefined;\r\n      if (typeof text !== 'string') return String(text);\r\n      return cleanText(text);\r\n    };\r\n\r\n    const toISOStringOrNull = (date: Date | null | undefined): string | null => {\r\n      return date ? date.toISOString() : null;\r\n    };\r\n\r\n    const parseArrayString = (input: unknown): string[] | null => {\r\n      if (typeof input === 'string') {\r\n        try {\r\n          const parsed = JSON.parse(input);\r\n          if (Array.isArray(parsed)) return parsed.map((x) => String(x));\r\n        } catch {}\r\n      }\r\n      return null;\r\n    };\r\n\r\n    const normalizeOptions = (options: unknown): string[] => {\r\n      const normalizeOne = (o: unknown) => {\r\n        try {\r\n          const s = typeof o === 'string' ? o : String(o);\r\n          const stripped = s.replace(/^\\s*[\"']|[\"']\\s*$/g, '');\r\n          const decoded = decodeHTMLEntities(stripped);\r\n          return decoded;\r\n        } catch (err) {\r\n          console.error('Error in normalizeOne:', err, 'Input:', o);\r\n          return String(o);\r\n        }\r\n      };\r\n\r\n      try {\r\n        if (Array.isArray(options)) {\r\n          return (options as unknown[]).map(normalizeOne);\r\n        }\r\n        const parsed = parseArrayString(options);\r\n        if (parsed) {\r\n          return parsed.map(normalizeOne);\r\n        }\r\n        return [];\r\n      } catch (err) {\r\n        console.error('Error in normalizeOptions:', err, 'Input:', options);\r\n        return [];\r\n      }\r\n    };\r\n\r\n    // Helper function to ensure JSON fields are properly serializable\r\n    // Moved outside the map to avoid recreation on every iteration\r\n    const safeJsonParse = (value: unknown): unknown => {\r\n      if (value == null) return null;\r\n      \r\n      try {\r\n        // If it's already an object/array, ensure it's serializable by round-tripping\r\n        // This removes undefined values and ensures no circular references\r\n        if (typeof value === 'object') {\r\n          return JSON.parse(JSON.stringify(value));\r\n        }\r\n        \r\n        // If it's a string, try to parse it\r\n        if (typeof value === 'string') {\r\n          try {\r\n            return JSON.parse(value);\r\n          } catch {\r\n            return value;\r\n          }\r\n        }\r\n        \r\n        return value;\r\n      } catch (err) {\r\n        console.error('[/api/questions] Error in safeJsonParse:', err, 'Input:', typeof value);\r\n        return null;\r\n      }\r\n    };\r\n\r\n    const normalizedQuestions = questions.map((q) => {\r\n      try {\r\n        // Extract ID prefix once for consistent logging\r\n        const questionIdShort = q.id.substring(0, 8);\r\n\r\n        const result = {\r\n          id: q.id,\r\n          question: cleanText(q.question),\r\n          explanation: cleanText(q.explanation),\r\n          passage: typeof q.passage === 'string' ? cleanText(q.passage) : q.passage,\r\n          options: normalizeOptions(q.options),\r\n          correctAnswer: q.correctAnswer,\r\n          tags: Array.isArray(q.tags) ? q.tags : [],\r\n          imageUrl: q.imageUrl,\r\n          imageAlt: cleanOptionalText(q.imageAlt),\r\n          source: cleanOptionalText(q.source),\r\n          difficulty: q.difficulty,\r\n          category: q.category,\r\n          subtopic: q.subtopic,\r\n          moduleType: q.moduleType,\r\n          timeEstimate: q.timeEstimate,\r\n          chartData: safeJsonParse(q.chartData),\r\n          wrongAnswerExplanations: safeJsonParse(q.wrongAnswerExplanations),\r\n          reviewStatus: q.reviewStatus,\r\n          reviewComments: q.reviewComments,\r\n          reviewedBy: q.reviewedBy,\r\n          reviewedAt: toISOStringOrNull(q.reviewedAt),\r\n          createdAt: q.createdAt.toISOString(),\r\n          updatedAt: toISOStringOrNull(q.updatedAt),\r\n          // Explicitly include subtopicRef to ensure proper serialization\r\n          subtopicRef: q.subtopicRef ? {\r\n            id: q.subtopicRef.id,\r\n            name: q.subtopicRef.name,\r\n            description: q.subtopicRef.description || null,\r\n            topic: q.subtopicRef.topic ? {\r\n              id: q.subtopicRef.topic.id,\r\n              name: q.subtopicRef.topic.name,\r\n              moduleType: q.subtopicRef.topic.moduleType\r\n            } : null\r\n          } : null\r\n        };\r\n\r\n        // Verify this individual question is JSON-serializable\r\n        try {\r\n          JSON.stringify(result);\r\n        } catch (itemError) {\r\n          console.error(`[/api/questions] Question ${questionIdShort} failed serialization:`, itemError);\r\n          console.error('[/api/questions] Problematic fields:', {\r\n            hasChartData: !!q.chartData,\r\n            hasWrongAnswerExplanations: !!q.wrongAnswerExplanations,\r\n            hasOptions: !!q.options,\r\n            hasSubtopicRef: !!q.subtopicRef\r\n          });\r\n          throw itemError;\r\n        }\r\n\r\n        // Log diagram info for debugging\r\n        if (q.chartData || q.imageUrl) {\r\n          console.log(`[/api/questions] Question ${questionIdShort}: chartData=${!!q.chartData}, imageUrl=${!!q.imageUrl}`);\r\n        }\r\n\r\n        return result;\r\n      } catch (err) {\r\n        console.error(`[/api/questions] Error normalizing question ${q.id}:`, err);\r\n        throw err;\r\n      }\r\n    });\r\n\r\n    const duration = Date.now() - startTime;\r\n    console.log(`[/api/questions] Request completed in ${duration}ms, returning ${normalizedQuestions.length} questions`);\r\n\r\n    // Build response object\r\n    const responseData = {\r\n      questions: normalizedQuestions,\r\n      pagination: {\r\n        total: totalCount,\r\n        limit,\r\n        offset,\r\n        hasMore: offset + limit < totalCount\r\n      },\r\n      filters: {\r\n        categories: categories.map(c => c.category).filter(Boolean),\r\n        subtopics: subtopics.map(s => s.subtopic).filter(Boolean),\r\n        sources: sources.map(s => s.source).filter(Boolean)\r\n      }\r\n    };\r\n\r\n    // Final safety check: ensure the response is JSON-serializable\r\n    try {\r\n      JSON.stringify(responseData);\r\n    } catch (serializationError) {\r\n      console.error('[/api/questions] Response serialization failed:', serializationError);\r\n      return NextResponse.json({\r\n        error: 'Failed to serialize response',\r\n        details: serializationError instanceof Error ? serializationError.message : 'Unknown serialization error',\r\n        timestamp: new Date().toISOString()\r\n      }, { status: 500 });\r\n    }\r\n\r\n    return NextResponse.json(responseData);\r\n    \r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    console.error(`[/api/questions] Error after ${duration}ms:`, error);\r\n    if (error instanceof Error) {\r\n      console.error('[/api/questions] Error name:', error.name);\r\n      console.error('[/api/questions] Error message:', error.message);\r\n      console.error('[/api/questions] Error stack:', error.stack);\r\n    }\r\n    \r\n    // Check if it's a Prisma error\r\n    let errorMessage = 'Failed to fetch questions';\r\n    const errorDetails = error instanceof Error ? error.message : String(error);\r\n    \r\n    if (error && typeof error === 'object' && 'code' in error) {\r\n      const prismaError = error as { code: string; meta?: unknown };\r\n      console.error('[/api/questions] Prisma error code:', prismaError.code);\r\n      \r\n      if (prismaError.code === 'P2002') {\r\n        errorMessage = 'Database constraint violation';\r\n      } else if (prismaError.code === 'P2025') {\r\n        errorMessage = 'Record not found';\r\n      } else if (prismaError.code.startsWith('P')) {\r\n        errorMessage = 'Database error';\r\n      }\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      error: errorMessage,\r\n      details: errorDetails,\r\n      timestamp: new Date().toISOString(),\r\n      stack: process.env.NODE_ENV === 'development' && error instanceof Error ? error.stack : undefined\r\n    }, { status: 500 });\r\n}\r\n}"],"names":[],"mappings":"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","debugId":null}}]
}